# Искусственный мир - Симуляция
**ideas/algoritm.py** - основа алгоритма без интерфейсов, пытался подключить многопточность и посчитать за сколько времени пройдет 10000 шагов симуляции. <br />
**ideas/main_ver2_class.py** - попытка подключить алгоритм к интерфейсу DearPyGui <br />
**ideas/pygm.py** - базовый (простой алгоритм) на интерфейсе PyGame <br />
**requirements.txt** - зависимости для трех этих файлов <br />

Проект представляет собой симуляцию искусственного мира. Мир состоит из клеток, которые могут выполнять различные действия, такие как размножение, атака, фотосинтез и поворот.

## Описание проекта
- **Функции клеток**:
  - **Размножение**: Клетки могут размножаться, создавая новые клетки в соседних клетках, также нужна система реализции "потомков", чтобы знания клеток передавались, иначе развитие будет отсутствовать.
  - **Атака**: Клетки могут атаковать другие клетки.
  - **Фотосинтез**: Клетки могут получать "халявную" энергию через фотосинтез, при этом ничего не делая, что позволяет им выживать и развиваться.
  - **Поворот**: Клетки могут поворачиваться, изменяя свое направление.

### Будущие планы:
- Добавление различных типов миров с уникальными правилами и характеристиками.
- Улучшение взаимодействия между клетками.
- Введение новых функций и возможностей для клеток.

### Возможные проблемы:
- С увеличением размера мира (1000х1000) очень падает оптимизация.
- Если подключить многопоточность мы сталкнемся со следующей проблемой -

![image](https://github.com/user-attachments/assets/fd5e73d2-0bb6-4c18-ab96-2361c6a627db)

### Его комментарии в телеграме:
> Я создаю поле:
>
> ```java
> _WORLD_MAP = new CellObject[MAP_CELLS.width][MAP_CELLS.height];
> ```
>
> Каждая клетка этой карты — клетка поля. Пока она может быть или `null`, или объект поля. Хотя позже я думаю, что каждая клетка будет полноценным объектом, у которого будет отдельное поле, показывающее, есть тут клетка или нет. Но это не важно. Важно, что есть карта поля.
>
> Затем я прохожусь в цикле от `0` до `maxY` и от `0` до `maxX` и создаю объект `Point(x, y)`. Эти точки я нарезаю на области, согласно выше приведённой схеме, и раскладываю по объектам потоков:
>
> ```java
> new WorldTask(firstList.toArray(Point[]::new), secondList.toArray(Point[]::new));
> ```
>
> Ну а дальше, в каждом шаге, я запускаю пул потоков на эти задачи:
>
> ```java
> maxExecutor.invokeAll(cellsTask);
> ```
>
> В потоке есть цикл по клеткам его области. Те самые `Point`, которые выше были нарезаны. Ну и, конечно, клетки выбираются рандомным образом. Если в клетке поля по координатам `point.x` и `point.y` есть клетка — она ходит....
>
> Ну а собственно функция `invokeAll` вернёт управление потоку, только когда все её задачи окажутся выполнены...
>
> Скомкано... Но как-то так :)
